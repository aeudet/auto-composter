import random
import string
import copy

#### Major/Minor ####

major_minor = random.choice(["major", "minor"])

#### Key Section ####

if major_minor == "major":
	key = random.choice(["C Major", "G Major", "D Major", "A Major", "E Major", "B Major", "F# Major", "Db Major", "Ab Major", "Eb Major", "Bb Major", "F Major"])
elif major_minor == "minor":
	key = random.choice(["A Minor", "E Minor", "B Minor", "F# Minor", "C# Minor", "G# Minor", "Eb Minor", "Bb Minor", "F Minor", "C Minor", "G Minor", "D Minor"])

#### Tempo Section ####

bpm_range = range(54,141) # Range of bpm
bpm = random.choice(bpm_range) # Chosen bpm
	
if bpm >= 54 and bpm < 65:
	tempo = "Adagio"
elif bpm >= 65 and bpm < 75:
	tempo = "Adagietto"
elif bpm >=75 and bpm < 84:
	tempo = "Andantino"
elif bpm >=84 and bpm < 90:
	tempo = "Andante"
elif bpm >=90 and bpm < 100:
	tempo = "Andante Moderato"
elif bpm >=100 and bpm < 112:
	tempo = "Moderato"
elif bpm >=112 and bpm < 116:
	tempo = "Allegro Moderato"
elif bpm >=116 and bpm < 141:
	tempo = "Allegro"
else:
	tempo = "Error"


#### Song Chords ####

# Generates length of progression
def progression_length_bars():
	progression_length_bars = random.choice([1] * 9 + [2] * 12 + [4] * 59 + [8] * 13 + [12] * 7)
	return progression_length_bars

# Generates number of chords for one bar
def chords_per_bar():
	chords_per_bar = random.choice([1] * 84 + [2] * 12 + [3] * 2 + [4] * 2)
	return chords_per_bar

# Generates list of chords per bar for a number_of_bars
def chords_per_bar_list(number_of_bars):
	chord_list = []
	for i in xrange(number_of_bars):
		chord_list.append(chords_per_bar())
	return chord_list


chord_chain_major = {
	"start": {"I":4, "IV":1, "V":1},
	"I": {"I": 1, "ii": 1, "iii": 1, "IV": 1, "V": 1, "vi": 1, "vii": 1},
	"ii": {"V": 1, "vii": 1},
	"iii": {"vi": 1, "IV": 1, "ii": 1},
	"IV": {"V": 1, "vii": 1},
	"V": {"I": 1, "vi": 1},
	"vi": {"ii": 1, "IV": 1},
	"vii": {"I": 1, "vi": 1}
}

chord_chain_minor = {
	"start": {"i":4, "iv":1, "v":1},
	"i": {"i": 1, "ii": 1, "III": 1, "iv": 1, "v": 1, "VI": 1, "VII": 1},
	"ii": {"v": 1, "VII": 1},
	"III": {"VI": 1, "iv": 1, "ii": 1},
	"iv": {"ii": 1, "VII": 1, "v": 1, "i": 1},
	"v": {"i": 1, "VI": 1},
	"VI": {"iv": 1, "ii": 1},
	"VII": {"III": 1}
}

def chord_gen(chain, length):
	progression = []
	prev = "start"
	for i in xrange(length):
		try:
			choice = random.randint(1, sum(chain[prev].values()))
			cumulative = 0
			for item, chance in sorted(chain[prev].items()):
				cumulative += chance
				if choice <= cumulative:
					progression.append(item)
					prev =  item
					break
		except KeyError:
			print "KEYERROR: CHORD"
			break
	return progression

#### Song Structure ####

total_sections = random.choice(range(2,7))

chain = {
	"A": {"A": 1, "B": 4, "C": 4, "D": 4, "E": 3, "F": 3},
	"B": {"A": 4, "B": 1, "C": 4, "D": 3, "E": 3, "F": 3},
	"C": {"A": 4, "B": 4, "C": 1, "D": 4, "E": 3, "F": 3},
	"D": {"A": 2, "B": 2, "C": 2, "D": 1, "E": 4, "F": 3},
	"E": {"A": 3, "B": 3, "C": 3, "D": 3, "E": 1, "F": 4},
	"F": {"A": 3, "B": 3, "C": 3, "D": 3, "E": 3, "F": 1},
	"G": {"A": 1, "B": 1, "C": 1, "D": 1, "E": 1, "F": 1}
}

def struct_gen(chain, start, length):
	structure = []
	depth = 1
	prev = start[-1:]
	structure.append(start)
	adjusted_length = range(length)
	for i in adjusted_length:
		try:
			choice = random.randint(1, sum(chain[prev].values()))
			cumulative = 0
			for item, chance in sorted(chain[prev].items()):
				cumulative += chance
				if choice <= cumulative:
					if sorted(chain[prev]).index(item) <= depth:
						structure.append(item)
						prev = item
						if sorted(chain[prev]).index(item) == depth:
							depth += 1
					else:
						adjusted_length.append(1)
					break
		except KeyError:
			print "KEYERROR: STRUCTURE"
			break
	return structure

#### Repeat Number ####

def generate_repeats(chords_per_bar):
	repeat_list = [2] * 2 + [4] * 10 + [8] * 18 + [12] * 35 + [16] * 20 + [18] * 10 + [24] * 5

	if chords_per_bar >= 1 and chords_per_bar < 4:
		return random.choice(repeat_list) * 2
	elif chords_per_bar >= 4 and chords_per_bar < 8:
		return random.choice(repeat_list)
	elif chords_per_bar >= 8 and chords_per_bar < 12:
		return random.choice(repeat_list)
	elif chords_per_bar >= 12 and chords_per_bar < 16:
		return random.choice(repeat_list)
	else:
		return "Error"

#### Output ####

chords_bar_list = []
progression_length = []
progressions = []
repeats = []
for i in xrange(7):
	progression_length.append(progression_length_bars())
	chords_bar_list.append(chords_per_bar_list(progression_length[-1]))
	progressions.append(chord_gen(chord_chain_major if major_minor == "major" else chord_chain_minor, sum(chords_bar_list[-1])))
	repeats.append(generate_repeats(len(chords_bar_list[i])))

progressions_with_bars = copy.deepcopy(progressions)
for i in xrange(7):
	cumulative = 0
	for bar in xrange(progression_length[i]):
		cumulative += chords_bar_list[i][bar]
		progressions_with_bars[i].insert(cumulative, "|")
		cumulative += 1


overall_structure = struct_gen(chain, "A", total_sections)

overall_structure_repeats = []
overall_structure_progressions = []
# same as above
alphabet = list(string.ascii_uppercase)
for section in overall_structure:
	for i in xrange(7):
		if section == alphabet[i]:
			overall_structure_progressions.append(progressions_with_bars[i])
			overall_structure_repeats.append(repeats[i])
			break
# Display key
print key
# Display tempo
print tempo + ": " + str(bpm) + " bpm"

for i in xrange(7):
	print alphabet[i] + ": | " + " ".join(progressions_with_bars[i]) + " x " + str(repeats[i])

print overall_structure
for i in xrange(len(overall_structure)):
	print overall_structure[i] + ": | " + " ".join(overall_structure_progressions[i]) + " x " + str(overall_structure_repeats[i])
