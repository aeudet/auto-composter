REPEATS

We generate a repeat unique repeat value for each section of a song.

ex. (A B A C A)

Each section, even the multiple "A" sections get a unique repeat value. This value is printed at the end of each section.

THE LOGIC:

- First, we generate a base value. The value is selected from a container with numbers ranging from 2 to 24. The values will be weighted so the extreme ones are less frequent.


- Next, we look at how many bars long the progression is for that section of the song. If a progression is a low amount of bars within a certain range, we select from another container [Repeat_Modifier] with weighted values specific to that number of bars in progression.


- Finally, we take the [Base_Value] + [Repeat_Modifier] to get a [Total_Repeats]


Example:

Base value = 24
Repeat modifier = 8

[24] + [8] = 32


Repeat Modifiers are as follow:

Base_Value = [2] * 2 + [4] * 10 + [8] * 18 + [12] * 35 + [16] * 20 + [18] * 10 + [24] * 5

Repeat_Modifier_low = [12] * 10 + [16] * 15 + [18] * 18 + [24] * 15 + [32] * 15

Repeat_Modifier_med = [4] * 10 + [8] * 15 + [10] * 18 + [12] * 15 + [16] * 15 

Repeat_Modifier_hi = [2] * 10 + [4] * 15 + [8] * 18 + [12] * 5


####### TEST ZONE ######

def generate_repeat_modifier_low():
	return random.choice([12] * 11 + [16] * 20 + [18] * 12 + [24] * 8 + [32] * 3)

def generate_repeat_modifier_hi():
	return random.choice([2] * 10 + [4] * 15 + [8] * 18 + [12] * 5)
	
def generate_repeats(bars_per_progression):
	repeat_list = [2] * 2 + [4] * 10 + [8] * 18 + [12] * 35 + [16] * 20 + [18] * 10 + [24] * 5
	if bars_per_progression >= 1 and bars_per_progression < 4:
		return random.choice(repeat_list) * 2
	elif bars_per_progression >= 4 and bars_per_progression < 8:
		return random.choice(repeat_list)
	elif bars_per_progression >= 8 and bars_per_progression < 12:
		return random.choice(repeat_list)
	elif bars_per_progression >= 12 and bars_per_progression < 16:
		return random.choice(repeat_list)
	else:
		return "Error"





